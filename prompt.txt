Você é um arquiteto full-stack sênior. Construa o Animabook (Laravel 12 + MySQL + Inertia React 19 + Tailwind v4) como um monólito único.
Restrições obrigatórias:

UI na hospedagem via Inertia (não existe API pública separada do app).

Jobs rodam em servidor worker separado, mas usando o MESMO repo/release e o MESMO banco MySQL da hospedagem.

Sem Redis (sem cache Redis, sem queue Redis, sem rate-limiter Redis).

Front não consome Jikan diretamente; tudo vem do MySQL.

Integração com dados via Jikan (docs.api.jikan.moe) e organização inspirada em jikan-me/jikan (PHP).

1) Estrutura do sistema (1 app, 2 execuções)

Hospedagem: PHP web serve Inertia (SSR opcional, mas não obrigatório), lê/escreve no MySQL.

Worker remoto: apenas executa schedule:run e queue:work com QUEUE_CONNECTION=database.

Garantir compatibilidade de migrations e versionamento (worker e hospedagem precisam estar no mesmo release).

2) Padrão de dados: ingestion-first (cadastro automático)

Tudo que for “catálogo” (anime, manga, character, person, genres, producers, magazines, seasons, top, reviews, recommendations, clubs, watch, random, etc.) é populado somente via Jobs.

O Inertia renderiza sempre a partir do MySQL.

“Cache” é feito com tabelas no MySQL (e opcionalmente file cache), nunca Redis.

3) Cobertura TOTAL do Jikan (módulos)

Implementar pipelines e telas para TODOS os módulos do Jikan (list/detail quando aplicável) incluindo sub-recursos e relações:
Anime, Manga, Characters, People, Users, Seasons, Top, Producers, Magazines, Reviews, Recommendations, Advanced Search, Watch, Clubs, Random, Genres.

4) Camada de Integração (inspirada no jikan-me/jikan)

Criar app/Integrations/Jikan/:

JikanHttpClient (timeout, retry, backoff, user-agent, logs, normalização de erros)

Endpoints/* (um por módulo)

DTO/* (tipos mínimos)

Mappers/* (payload → colunas indexáveis + payload bruto)

Ingestor (upsert + pivôs + refresh)

RefreshPolicy (regras por tipo/status/idade)

IngestBudget (controle de custo/limites por janela de tempo)

5) Modelagem MySQL (catálogo + relações + usuário)

Catálogo (genérico e escalável)

catalog_entities:

entity_type, mal_id (unique)

title, title_normalized

synopsis_short (index FULLTEXT opcional)

year, season, status, rating, score, rank, popularity, members, favorites

images (json), trailer (json), external_links (json)

payload (json bruto)

last_fetched_at, next_refresh_at

fetch_failures, last_error

Relações (grafo controlado)

entity_relations:

from_type/from_mal_id, to_type/to_mal_id

relation_type (genre/producer/character/recommendation/sequel/staff/etc)

weight (int) (ex.: para “recommendations”)

meta (json)

unique keys por relação

Dados do Animabook (usuário)

user_media_status (watchlist + progresso + nota pessoal + notas)

user_favorites (entity_type+mal_id)

user_votes (scope + anime_mal_id, unique(user_id,scope))

Cache no MySQL (substitui Redis)

jikan_cache (key, endpoint, query_json, payload_json, status_code, fetched_at, expires_at)

6) Índices MySQL (pra não virar carroça)

Implementar índices de alta utilidade:

catalog_entities:

UNIQUE(entity_type, mal_id)

INDEX(entity_type, score)

INDEX(entity_type, rank)

INDEX(entity_type, popularity)

INDEX(entity_type, year, season)

INDEX(entity_type, status)

INDEX(title_normalized)

FULLTEXT(title, synopsis_short) (se MySQL/MariaDB suportar) para busca rápida

entity_relations:

INDEX(from_type, from_mal_id, relation_type)

INDEX(to_type, to_mal_id, relation_type)

UNIQUE(from_type, from_mal_id, to_type, to_mal_id, relation_type)

user tables:

UNIQUE(user_id, media_type, mal_id) / UNIQUE(user_id, entity_type, mal_id)

INDEX(user_id, status)

Busca sem Elastic:

busca por título via title_normalized LIKE 'naruto%' (prefix) + fallback FULLTEXT

query builder com filtros compostos usando índices

7) Política de descoberta (Seed Strategy) — SEM explodir o universo

Objetivo: preencher catálogo relevante sem “varrer todo MAL”.

Implementar SeedStrategy por camadas:

Baseline diário (curto e valioso)

Top (anime/manga) páginas 1–N (N pequeno, ex: 5)

Temporada atual + próxima (seasons)

Trending/popular (se disponível via endpoints)

Search curado (controle de custo)

queries de descoberta por letras (“a”, “b”, “c”… com paginação mínima) apenas em janelas programadas

ou por faixas de ano (ex.: 2026, 2025...) com limites

Expansão de grafo controlada

ao sincronizar um anime, coletar:

recommendations top K

relations diretas (sequels/prequels)

personagens principais top K

não seguir infinitamente (limite de profundidade e orçamento)

Regras anti-explosão (obrigatórias):

limite de “novos IDs enfileirados” por entidade (K)

limite de profundidade do grafo (ex.: 2)

“orçamento diário” de ingest (ex.: 10k chamadas/dia) guardado em MySQL (ingest_budgets)

se orçamento estourar: adiar fila low automaticamente

8) Jobs e governança de carga (sem Redis)

Filas no driver database:

high, default, low (3 filas)

worker roda --queue=high,default,low

Jobs mínimos:

SeedTopJob

SeedSeasonsJob

SeedDiscoveryJob (curado)

SyncEntityJob(entityType, malId)

SyncRelationsJob(entityType, malId)

RefreshPlannerJob

RebuildSearchIndexJob (opcional: recalcula title_normalized, etc.)

Idempotência e locks:

SyncEntityJob deve:

verificar lease/lock (MySQL) antes de processar

marcar “processing” e “lease_expires_at”

ao final, liberar lease

usar unique constraints para impedir duplicatas

backoff exponencial em falhas e limites de retry

Scheduler (cron no worker):

a cada 10–30 min: baseline (top + season)

diariamente: refresh planner + seeds curados

semanal: deep crawl limitado (fila low)

9) Inertia Pages (sem API paralela)

Construir páginas Inertia com controllers Laravel que consultam MySQL:
Público

/ (Home)

/anime (list + filtros)

/anime/{mal_id} (detail com tabs)

/manga, /characters, /people, /seasons, /top, /genres, /producers, /magazines, /clubs, /watch, /random

/ranking/melhor-anime

Autenticado

/app/dashboard

/app/watchlist

/app/favoritos

/app/votar

/app/perfil

Contrato de props Inertia:

list pages: items, meta, filters, sort, stats

detail pages: entity, relationsByType, recommendations, reviews, characters

10) UX / Branding

Nome: Animabook

Paleta baseada na logo (pêssego/rosa + cacau) com tokens Tailwind v4 e dark mode

Componentes premium + skeleton + empty states + mensagens amigáveis

11) Entregáveis

Estrutura de pastas (Domain + Integrations/Jikan)

Migrations + índices

Jobs + Scheduler + queue database

Pages React (Inertia) + UI kit

Testes (Pest) para ingest idempotente + voto único + watchlist/favoritos

Regra final: o site é sempre rápido porque lê do MySQL. O worker mantém o catálogo atualizado assíncronamente.
